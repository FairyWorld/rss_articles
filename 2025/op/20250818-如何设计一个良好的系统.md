## 良好的软件系统设计

上周读到一篇文章，作者是 GitHub 的高级工程师[肖恩·戈德克](https://www.seangoedecke.com/)（sean goedecke）。

![](https://cdn.beekka.com/blogimg/asset/202508/bg2025081814.webp)

文章题目是[《我所知的良好的系统设计》](https://www.seangoedecke.com/good-system-design/)。

![](https://cdn.beekka.com/blogimg/asset/202508/bg2025081818.webp)

大家知道，GitHub 的系统设计，公认非常优秀，实际用起来也很顺手。所以，我很好奇，它的工程师会怎么总结经验，教大家设计一个良好的系统。

读完后，我觉得写得不错，有干货，不是空泛之谈。下面是我的一些摘录。

### 1、什么是系统设计？

程序设计是组装代码，系统设计是组装服务。

程序设计的组件是变量、函数、类等，系统设计的组件是服务器、数据库、缓存、队列、事件总线、代理等。

### 2、什么是良好的系统设计

如果一个系统很长时间不出错，它的设计就是良好的。

如果你进一步看了代码，禁不住认为：“哈，这比我想的要简单”，或者“系统的这个部分不用我操心，即使出问题也容易解决”，那么它的设计就是优秀的。

### 3、简单性

良好的系统设计，总是从一个有效的简单系统发展而来。

始终保持系统简单。

如果你要从零开始设计一个复杂的系统，最终做出来的系统往往很糟糕。

### 4、状态

系统设计的难点在于状态。

需要存储信息的应用，就是有状态的。不存储信息，就是无状态的应用。

优先采用无状态组件，最小化“有状态组件”的数量。

状态的复杂性在于，你无法简单地重启服务。一旦出错，往往需要手动修复状态。

### 5、数据库

状态保存在数据库。

系统设计的最重要部分是状态管理，最重要的组件是数据库。

数据库的表结构（也就是数据结构）要简单，否则会给代码带来极大的复杂性和性能限制。

数据库的设计目标应该是每张表易于理解：打开看一下表结构，就能大致了解存储的数据内容及其原因。

### 6、数据库瓶颈

高访问量的系统中，数据库通常是瓶颈，因为每个请求往往要调用数十次、数百次数据库，而且是按顺序调用。

如何避免瓶颈？

（1）不要自己拼接数据，而是直接查询数据库。数据库来做这项工作几乎总是比自己做更高效。

（2）数据库做成一个写入节点和多个只读副本。查询都发往只读副本，写入节点不读取数据。

（3）如果你无法容忍任何的数据复制延迟（比如更新一条记录后，需要立即使用它），你可以将数据放到内存中，写入数据库成功后，从内存读取而不是立即重新读取数据库。

### 7、后台作业

后台作业是系统外部的单独服务。缓慢的操作（比如将 PDF 转换为 HTML）应该拆分出来，改成后台作业，排队放到后台完成。

后台作业主要由两个组件组成：一个队列服务，一个作业运行器服务，它会从队列中获取并执行任务。

如果队列任务需要尽快运行，队列软件可以使用 Redis。如果队列任务不着急，可以在一天或一周内运行，队列软件就使用数据库。

### 8、缓存

有些操作很慢，但又要经常查询，经典解决方案就是缓存。

最简单的缓存，就是把数据保存在内存中，但也可以保存在专门的键值存储软件（比如 Redis 或 Memcached）。后者的好处是多个服务器可以共享一个缓存。

初级工程师希望缓存所有内容，而高级工程师希望尽可能少地缓存，因为缓存是状态的来源，不可避免需要校验状态和处理状态过期。所以，首先尽可能提高系统处理查询的能力，如果实在不能满足要求，才考虑缓存。

### 9、事件

除了缓存和后台作业，大型系统通常还有一个事件中心，一般用的工具是 Kafka。

事件中心也是一个队列，存放的是“某件事发生了”的消息，比如用户注册触发了“新帐户创建”事件，该事件放入事件中心后，由事件中心去通知监听该事件的多个服务：发送欢迎电子邮件、设置个人空间等等。

不要过度使用事件，很多时候，更简单的做法是让一个服务请求另一个服务的 API。

事件中心的适用场合是，发送事件的代码不关心其他服务如何处理事件，或者事件量很大且对响应时间不太敏感。

为了便于除错，所有日志最好都放在同一个地方，你可以立即看到另一个服务的响应。

### 10、推拉

一个地方的数据传送到其他多个地方时，有两种选择。最简单的方法是拉取（pull），比如大多数网站采用的轮询，浏览器不断向服务器请求拉取数据。

另一种方法是推送（push），用户不主动请求数据，后端数据发生变化时，服务器将数据推送给每个客户端。

一般来说，拉取的实现比较简单，推送更节省资源。

如果你确实需要向一百万个客户端提供最新数据（就像 GMail 那样），应该采用推送还是拉取？这要视情况而定。如果采用推送，就要把每次推送放入一个事件队列，并让一大群事件处理器从队列中拉取并推送。如果采用拉取，就要在部署一堆（比如100台）快速的只读缓存服务器，处理所有读取流量。
