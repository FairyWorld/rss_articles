## 如何设计一个良好的软件系统

https://www.seangoedecke.com/good-system-design/

GitHub 高级工程师 肖恩·戈德克（sean goedecke）

![](https://cdn.beekka.com/blogimg/asset/202508/bg2025081814.webp)

我们知道，GitHub 是一个非常复杂的大型系统，运行很理想。我就想看看他怎么说，怎么设计一个良好的软件系统。

我觉得文章写得很好，是很好的经验总结。下面摘录几点。

1、

什么是系统设计？在我看来，如果软件设计是组装代码的方式，那么系统设计就是组装服务的方式。

软件设计的原语是变量、函数、类等等。系统设计的原语是应用服务器、数据库、缓存、队列、事件总线、代理等等。

2、

好的系统设计是什么样的？实际上，它看起来很长时间都没有出错。

它能正常工作，而且你看了代码，会产生这样的想法：“哈，这比我预期的要容易”，或者“我从来都不用考虑系统的这个部分，没问题”，那么你就可以知道你面对的是好的设计。

3、

一个有效的复杂系统总是从一个有效的简单系统发展而来。从零开始开发一个复杂的系统是一个非常糟糕的主意。

4、状态

软件设计的难点在于状态。如果你要存储任何类型的信息，无论存储多长时间，你都需要做出许多关于如何保存、存储和提供这些信息的棘手决策。如果你不存储信息 2 ，你的应用就是“无状态的”。

任何写入数据库的操作都是有状态的。

你应该尝试在任何系统中最小化“有状态组件”的数量。因为状态会使得组件无法简单地重启，有状态的服务无法靠重启来自动修复。如果你的数据库中出现错误条目，往往需要手动修复。

5、数据库

数据库的作用就是保存状态。

状态管理是系统设计中最重要的部分，所以数据库就是最重要的组件。

数据库的表模式，不要过于灵活，这会给应用程序代码带来极大的复杂性和性能限制。

你的目标应该是你的表易于理解：打开看一下数据库模式，就能大致了解存储的内容及其原因。

如果你预计表的数据量会超过几行，则应该为其创建索引。尽量使索引与您发送的最常见查询匹配。

6、

在高流量应用程序中，访问数据库通常是瓶颈。这是因为复杂的应用程序需要进行大量的数据库调用——每个请求都要进行数百次调用，而且通常是顺序进行的。

如何避免瓶颈？

查询数据库时， 直接查询数据库 。让数据库来做这项工作几乎总是比自己做更高效。

向数据库副本发送尽可能多的读取查询。典型的数据库设置通常包含一个写入节点和多个读取副本。越能避免从写入节点读取数据越好。

如果你真的无法容忍任何复制延迟，那么当你更新一条记录但需要立即使用它时，你可以将更新的详细信息填充到内存中，而不是在写入后立即重新读取。

1、有些服务必须快速完成某些操作。如果用户正在与某个对象（例如，API 或网页）交互，他们应该在几百毫秒内看到响应 3 。但服务必须执行其他一些缓慢的操作。有些操作确实需要很长时间（例如，将非常大的 PDF 转换为 HTML）。对此的一般模式是 ，将对用户有用的最少工作拆分出来，其余工作在后台完成。在 PDF 转 HTML 的示例中，您可以立即将第一页渲染为 HTML，并将其余工作排队到后台作业中。

1、“后台作业”是核心系统设计原语。每家科技公司都会有某种系统来运行后台作业。它主要由两个组件组成：一个队列集合（例如 Redis），以及一个作业运行器服务，它会从队列中获取并执行任务。

1、对于速度较慢的操作，后台作业应该是你的首选。

1、有时，您需要构建自己的队列系统。如果您想将某个作业加入队列，尽快运行，可能使用 Redis。如果需要在更长时间运行（比如一周内运行），就使用数据库。

### 缓存

有时操作很慢，经典解决方案是缓存。比如，查询价格很慢，那就每五分钟查询一次价格，并同时存储值。

最简单的方法是将数据缓存在内存中，但使用一些快速的外部键值存储（如 Redis 或 Memcached）也很流行（因为这意味着您可以在一组应用服务器之间共享一个缓存）。

初级工程师希望缓存所有内容，而高级工程师则希望尽可能少地缓存。因为缓存是状态的来源，不可能避免需要校验状态和处理状态过期。

首先竭尽全力提高系统速度，如果还是不能满足要求，才考虑缓存。

## 事件

除了某种缓存基础设施和后台作业系统外，科技公司通常还会有一个事件中心 。最常见的实现是 Kafka。

事件中心只是一个队列——类似于后台作业的队列——但不是将“使用这些参数运行这个作业”放入队列，而是将“这件事发生了”放入队列。一个典型的例子是为每个新帐户触发一个“新帐户创建”事件，然后让多个服务使用该事件并采取一些行动：“发送欢迎电子邮件”服务、“扫描滥用行为”服务、“设置每个帐户的基础设施”服务等等。

不应过度使用事件。很多时候，最好只让一个服务向另一个服务发出 API 请求。

所有日志都放在同一个地方，更容易推理，而且您可以立即看到另一个服务的响应。

当发送事件的代码不一定关心消费者如何处理事件，或者事件量很大且对响应时间不太敏感时，事件是很好的选择。

## 推拉

当你需要将数据从一个地方传输到多个地方时，有两种选择。最简单的方法是拉取 。大多数网站都是这样运作的：你有一个服务器，其中包含一些数据，当用户需要这些数据时，他们会通过浏览器向服务器发出请求，请求服务器将这些数据拉取下来。但问题在于，用户可能会多次拉取相同的数据——例如，刷新邮箱查看是否有新邮件，这会拉取并重新加载整个 Web 应用程序，而不仅仅是邮件相关的数据。

另一种方法是推送 。您不再允许用户主动请求数据，而是让他们注册为客户端，然后当数据发生变化时，服务器会将数据推送给每个客户端。GMail 就是这样运作的：您无需刷新页面即可收到新邮件，因为它们会在到达时自动显示。

一般来说，拉取的实现比较简单，推送更节省资源。即使非常庞大的系统，最多可能只有大约一百个服务需要推送。对于变化不大的数据，每当数据发生变化时发出一百个 HTTP 请求（或 RPC 请求，或其他方式）要比每秒接受1000次查询容易得多。

假设你确实需要向一百万个客户端提供最新数据（就像 GMail 那样）。这些客户端应该采用推送还是拉取？这要视情况而定。如果采用推送，则可能意味着将每次推送都放入一个事件队列，并让一大群事件处理器分别从队列中拉取并发送推送。如果采用拉取，则意味着需要在主应用程序之前部署一堆（比如一百台）快速的读副本缓存服务器，处理所有读取流量。