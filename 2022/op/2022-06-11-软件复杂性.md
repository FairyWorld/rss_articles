## 本周话题：为什么软件变得复杂

上周，Saleforce 的著名前端工程师 Nolan Lawson 写了一篇文章，名字很有意思[《复杂软件的崩溃》](https://nolanlawson.com/2022/06/09/the-collapse-of-complex-software/)。

> 任何在科技行业工作足够长的人，尤其是在大型组织中工作的人，都曾见过它。存在一个遗留系统：它很大，很复杂，没有人完全理解它是如何工作的。建筑师被请来“修复”系统。他们可能会推出一个大白板，显示许多指向其他框的框和箭头，并且不可避免地，他们的解决方案是……添加更多框和箭头。没有人可以从系统中减去；每个人都只是补充。

![](https://nolanwlawson.files.wordpress.com/2022/06/vlcsnap-2022-06-04-11h31m52s707-1.jpg)

当这样的方框图画出来，就完蛋了，一个复杂的系统就诞生了。有一些高级管理人员，专注于绘制这样的方框图。如果他们大笔一挥，修改或增加一个方框，复杂性顿时就会继续上升。

繁荣时期，软件公司有快速上涨的需求，高管可能会画更多的方框，软件的复杂度继续上升。而且，他们偏偏可以继续雇佣新的员工来管理他们现有的软件（即更多的工程师来理解更多的方框和箭头），有财力和人力维持一个复杂的系统。但如果他们的劳动力被迫收缩，那么同样的系统可能会变得无法维护。

前两年是互联网公司的繁荣期，系统的复杂度一定上升了好多，招了很多人。现在，繁荣期结束，开始冻结招聘或者裁员，系统复杂性就会成为大问题。也许，我们马上就会看到故障高发。

https://news.ycombinator.com/item?id=31688436

（1）软件复杂性的来源是，我们对软件系统的期望比以往任何时候都复杂得多。它总是变得更加复杂，需求和愿望只会增加。

（2）有些开发人员喜欢构建复杂的结构，挑战自己，获取成就感。

（3）理论上，复杂系统是由一个复杂的、运作良好的、理性的组织管理的。在实践中它不起作用，原因有很多。业务驱动软件开发，而业务正在寻求利润。企业管理者真正在意的不是系统的复杂性，而是利润，只要能持续获得利润，他并不在意系统是复杂的，还是简单的。最终，软件复杂性都落到少数架构师和高级开发人员的头上，不可避免地，人们会在一段时间后离开组织。

https://news.ycombinator.com/item?id=31685329

软件复杂性的来源：

（1）开发者创建项目的时候没有经验，对项目也不够了解，没有事先周密准备就开始构建。

（2）由于业务需求变化，导致开发事先没有预计或计划过的功能，并尽可能快地构建。这会导致开发人员走捷径，做出不优雅且难以维护的设计选择。原始开发人员离开公司后，他留下了难以理解的代码，后面接手的程序员不敢或无法修改，软件又被用来赚钱，就形成了技术债务，时间拖得越久，问题变得越复杂。

（3）团队流动性高，开发人员不断变更，很多开发工作半途而废，或者由不同的人接手。

https://news.ycombinator.com/item?id=31683204

日本的[伊势神宫](https://zh.wikipedia.org/zh-cn/%E7%A5%9E%E5%AE%AB%E5%BC%8F%E5%B9%B4%E8%BF%81%E5%AE%AB)，据说每过20年，就拆掉重新建造，为的是让建造宫殿的知识不要被忘记，能够一直传下去。历史上，伊势神宫已经重建了62次，上一次重建是2013年。

[谷歌工程师](https://arxiv.org/pdf/1702.01715.pdf)透露，谷歌的大多数软件每隔几年就会重写一次。表面上看，这样做的代价非常昂贵，消耗了谷歌的大量资源。但是，它也有一些重要的好处，能够软件始终不会偏离技术趋势和市场变化太远，防止累计技术债务，保证了公司的敏捷性和长期成功。

（1）一般来说，几年的时间会让产品需求通常会发生显着变化。几年前的软件是围绕一组较旧的需求设计的，跟现在的需求通常不是以最适合当前需求的方式设计的。

（2）重写代码消除了不必要的累积复杂性，因为复杂性是不断累积的。很多需求在开发时只是一种预估，等到开发完成时，你可能发现根本不是那么一回事，要么没有使用最合适的方法解决这个问题，要么修改代码，适合实际的需求。当你重写软件时，你已经知道现实情况是什么样了，就会用更简单的方法处理，这样就消除了复杂性。

