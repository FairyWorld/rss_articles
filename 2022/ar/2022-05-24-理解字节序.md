# 字节序探析：大端与小端的比较

今天谈谈一个重要的计算机概念。大家可能都听说过它，但是很少深究，那就是字节序（Endianness）。

![](https://cdn.beekka.com/blogimg/asset/202206/bg2022060101.webp)

## 一、概念

字节序说起来比较抽象，就是 **多字节的数据在内存里面的排列顺序**。但是使用图形解释，就非常好懂。

内存就好像一排房间，每个字节是一间房。每间房都有自己的门牌号（内存地址），从0号房开始，然后是1号房、2号房……

![](https://cdn.beekka.com/blogimg/asset/202206/bg2022060102.webp)

0号字节的地址小，称为低位内存；3号字节的地址大，称为高位内存。

现在有一个数值`abcd`要放进这些房间，假定每个房间放一个数字，那么有两种放法。

第一种放法，数值的第一位`a`放在低位地址（0号地址），最后一位`d`放在高位地址（3号地址），这称为“<ins>大端序</ins>”（big-endian，简称 BE）。

![](https://cdn.beekka.com/blogimg/asset/202206/bg2022060103.webp)

第二种放法，数值的第一位`a`放在高位地址（3号地址），最后一位`d`放在低位地址（0号地址），这称为“<ins>小端序</ins>”（little-endian，简称 LE）。

![](https://cdn.beekka.com/blogimg/asset/202206/bg2022060104.webp)

“大端序”和“小端序”这两种顺序，合称字节序。它们的名字来自18世纪的英国小说《格列佛游记》。

小说里面，有一个国家的人分成两派。一派认为，鸡蛋应该先吃大头，称为“大端派”；另一派认为，鸡蛋应该先吃小头，称为“小端派”。两派相执不下，谁也无法说服谁，最后甚至为此交战。

![](https://cdn.beekka.com/blogimg/asset/202206/bg2022060105.jpg)

## 二、可读性

大部分国家的阅读习惯是从左到右阅读。

![](https://cdn.beekka.com/blogimg/asset/202206/bg2022060106.webp)

大端序的最高位在左边，最低位在右边，符合这种阅读习惯。所以，对于这些国家的人来说，**从左到右的大端序的可读性更好。**

但是现实中，小端序虽然可读性差，但应用更广泛，x86 和 ARM 这两种 CPU 架构内部都采用小端序，这是为什么呢？

进一步说，为什么会有两种不同的字节序，统一规定只使用一种，难道不是更方便吗？

## 三、检查奇偶性

下面，我们来看几种常见操作，大端序和小端序分别是怎么处理的。

检查奇偶性，大概是小端序优势最明显的场景。通过查看个位数，可以确定某个数字是奇数还是偶数。

![](https://cdn.beekka.com/blogimg/asset/202206/bg2022060112.webp)

以`123456`为例，大端序是从左到右排列。计算机必须一直读到最后的个位数`6`，才能确定这是偶数。

但是，小端序是从右到左排列，个位数在第一位。所以，只要读取第一位，就能确定它是偶数。

## 四、检查正负号

检查正负号也是类似的做法。

![](https://cdn.beekka.com/blogimg/asset/202206/bg2022060113.webp)

但是这时，大端序的符号位在左边的第一位，小端序的符号位在右边的最后一位。所以，大端序有优势，只看第一位就能知道是不是负数。

## 五、比较大小

下一种操作是比较大小。现在有三个数字，需要比较大小：43662576，594，2。

![](https://cdn.beekka.com/blogimg/asset/202206/bg2022060108.webp)

上图是这三个数的大端序排列方式，因为是从左到右的排列，所以它们在个位数对齐。

要对它们比较大小，计算机就不得不读取每一个数的所有位，再进行比较。

如果改成小端序，就是下面的排列方式。

![](https://cdn.beekka.com/blogimg/asset/202206/bg2022060109.webp)

小端序是从右到左排列，所以三个数字在第一位对齐。

计算机从每个数的第一位开始读取，这时比较大小就不需要读取所有位，哪个数字先读不到下一位，就是最小的。比如，`2`这个数字就没有第二位，所以读到第二位时，就知道它是最小的。

因此，比较大小时，小端序有优势。

## 六、乘法

接下来，再看乘法操作。

乘法是逐位相乘，每一轮乘法都要向前进位。

![](https://cdn.beekka.com/blogimg/asset/202206/bg2022060110.webp)

上图是24165乘以3841，两个数都是大端序。一个是5位数，另一个是4位数，相乘的结果是一个8位数，为了防止溢出，必须事先估计要留出多少位。

这是因为，大端序的乘法是向左进位，也就是向左边扩展，所以必须预留出足够的内存空间，存储乘法的结果。

如果改成小端序的乘法，就不需要预留空间了。

![](https://cdn.beekka.com/blogimg/asset/202206/bg2022060111.webp)

上图是小端序的24165乘以3841。因为小端序的乘法是向右进位，也就是向右边扩展，所以不需要事先估算需要占用的空间，直接写入后面的内存地址就可以了。

因此，小端序的乘法有明显优势。

## 七、更改类型

C 语言有一种 cast 操作，可以强制指定变量的数据类型，比如把32位指定为16位整数。

![](https://cdn.beekka.com/blogimg/asset/202206/bg2022060114.webp)

上图中，32位整数更改位为16位整数时，大端序是截去前面四个字节，这时指向这个变量地址的地址也必须向后移动四个字节。

反之，小端序就没有这个问题，直接截去后面四个字节，指针不需要移动。

## 八、任意精度整数

很多语言提供任意精度整数，又称为大整数（bigint），允许一个整数无限大。

它的内部实现是，把任意精度整数分成一个个 uint32（无符号32位整数）或 uint64（无符号64位整数），按顺序组合在一起。

![](https://cdn.beekka.com/blogimg/asset/202206/bg2022060115.webp)

如果是大端序，第一个 u64 就是这个整数最大的部分。一旦运算时，这个数变大需要进位，后面的所有位都必须移动和改写。小端序就没有这个问题，第一个 u64 是最小的部分，进位时在右侧边界增加新的位就可以了。

小端序的另一个好处是，逐字节的运算从个位数开始的话，就不用考虑这个数有多大了，一个个 u64 依次向后运算就可以了。

## 总结

如果需要逐位运算，或者涉及到个位数，都是小端序占优势。

如果运算只涉及到高位，或者看重数字的可读性，则是大端序占优势。

## 参考链接

https://www.technicalsourcery.net/posts/on-endianness/