# 输入与输出

## scanf()

`scanf()`函数用于读取用户的键盘输入。它会等待用户从键盘输入，然后将输入内容存入一个变量。

```c
scanf("%d", &i)
```

上面的代码表示，将用户从键盘输入的整数，存入变量`i`。

注意，`scanf()`要求变量前面必须加上`&`运算符，因为它传递的不是值，而是地址，即将变量`i`的地址改为用户输入的值的地址。

`scanf()`可以读取用户的输入，放进多个变量。

```c
scanf("%d%d%f%f", &i, &j, &x, &y);
```

上面的示例将用户的输入，依次放入`i`、`j`、`x`、`y`四个变量。

`scanf()`需要使用占位符告诉编译器，用户输入的数值是什么类型。它的占位符与`printf()`的占位符是一致的。它会按照占位符提示的格式，读取用户输入的变量。比如，占位符`%d`提示是一个整数，它从第一个非空白字符开始读起，直到遇到第一个非数字字符为止。

```c
-13.45e12# 0
```

举例来说，用户输入上面一串值。如果对应的占位符是`%d`，`scanf()`会读取到`-13`，然后停下来，下一次读取的首字符是`.`。如果对应的占位符是`%f`，会读取到`-13.45e12`，下一次读取的首字符是`#`号。如果对应的占位符是`%s`，会读取到`-13.45e12#`，下一次读取的首字符是空格符。

如果占位符是`%c`，它会读取当前第一个字符，无论该字符是否为空格。

如果占位符是`%s`，它会从第一个字符开始读起（无论是不是空格），直到遇到第一个非空白字符为止。由于遇到空格就会停止读取，所以无法利用设定占位符的字符宽度，让只有一个`%s`的`scanf()`读取多个单词。这意味着，`scanf()`不能读取包含空格的字符串，比如书名或歌曲名。

开始读取时，`scanf()`会忽略空白字符（包括空格符、水平制表符、垂直制表符、换页符和换行符），直到发现输入的字符匹配格式符为止。

`scanf()`占位符的格式规则，与`printf()`一致。比如，`scanf("%10s", name)`会读取10个字符或者读到第一个空白字符为止。

`scanf()`的返回值是一个整数，表示成功读取的项数。如果没有读取任何项，或者匹配失败（比如需要读取数字，用户输入了字符），则返回`0`。如果读取到文件结尾，则返回 EOF。

## getchar()

`getchar()`函数返回用户从键盘输入的一个字符，使用时不带有任何参数。它等同于使用`scanf()`方法读取一个字符。

```c
char ch;
ch = getchar();

// 等同于
char ch;
scanf("%c", &ch);
```

该方法的原型在`stdio.h`头文件里面定义。

## putchar()

`putchar()`函数将它的一个参数字符，输出到屏幕，等同于使用`printf()`输出一个字符。

```c
scanf("%c", &ch);

putchar(ch);
// 等同于
printf("%c", ch);
```

由于这两个函数只处理字符，所以要比`scanf()`和`printf()`更快。它们的原型定义在`stdio.h`头文件中。

## puts()

`puts()`用于将参数字符串显示在屏幕上，并且自动在字符串末尾添加换行符。

```c
puts("Here are some messages:");
puts("Hello World");
```

## gets()

C 语言以前有一个`gets()`函数用于读取整行输入，现在已经被废除了。

该函数读取用户的一行输入，直到遇到换行符。这个函数会丢弃换行符，储存其余字符，并在这些字符的末尾添加一个空字符`\0`，使其成为 C 语言的字符串。

它经常与`puts()`配合使用。

```c
char words[81];

puts("Enter a string, please");
gets(words);
```

上面示例使用`puts()`在屏幕上输出提示，然后使用`gets()`获取用户的输入。

由于`get()`获取的字符串，可能超过变量的最大长度，有安全风险，建议不要使用。

## fgets()，fputs()

`fgets()`函数用于读取输入的字符串。该函数专门设计用于处理文件输入，所以它的名字的第一个字符是`f`，代表`file`。

`fgets()`的第一个参数是储存字符串的变量名。

`fgets()`的第二个参数指定读取的字符串长度，防止用户输入过长的字符串。如果该参数是`n`，那么`fgets()`会读取到`n - 1`个字符为止，或者读取到第一个换行符为止。`fgets()`会将换行符储存在字符串中，这一点需要注意。

`fgets()`函数的第三个参数是要读取的文件。如果是读取键盘输入的数据，则使用`stdin`（标准输入）作为参数。

`fputs()`函数通常与`fgets`配对使用，用于输出字符串，常用来向文件写入内容。`fputs()`的用法与`puts()`类似，只有一点不同，那就是它不会在字符串末尾添加换行符。

`fputs()`的第一个参数是字符串变量，第二个参数是要写入的文件名。如果是要输出到计算机屏幕上，则使用`stdout`（标准输出）作为第二个参数。

```c
char words[14];

puts("Enter a string, please.");
fgets(words, 14, stdin);

puts("This is your string:");
fputs(words, stdout);
```

`fgets()`返回一个指向字符串的指针。如果一切顺利，返回的地址与第一个参数相同。但是，如果发生错误，或者读到了文件结尾，它将返回一个空指针（null pointer）。这个指针不会指向有效的数据，可以用宏 NULL 代替。使用这一点可以判断，是否读到了文件结尾。

```c
char words[10];

puts("Enter strings (q to quit):");

while (fgets(words, 10, stdin) != NULL) {
  if (words[0] == 'q' && words[1] == '\n')
    break;

  fputs(words, stdout);
}

puts("Done.");
```

上面的示例中，如果用户输入的字符串大于9个字符，`fgets()`会多次读取。如果希望丢弃那些多余的字符，可以参考下面的例子。

```c
char words[10];
int i;

puts("Enter strings (q to quit):");

while (fgets(words, 10, stdin) != NULL) {
  if (words[0] == 'q' && words[1] == '\n')
    break;

  fputs(words, stdout);

  i = 0;
  while (words[i] != '\n' && words[i] != '\0')
    i++;

  if (words[i] == '\0') {
    while (getchar() != '\n') continue;
    fputs("\n", stdout);
  }
}

puts("Done.");
```

上面示例中，如果用户输入的字符串大于9个字符（不含最后的换行符），多于9个字符的部分使用`getchar()`从缓存中读出并丢弃。由于丢弃时不会输出最后的换行符，所以丢弃结束后补输出一个换行符。

## gets_s()

`gets_s()`函数与`fgets()`类似，使用一个参数限制读入的字符串。

```c
gets_s(words, StrLen);
```

它与`fgets()`的区别是：

- `gets_s()`只从标准输入中读取数据，所以不需要第3个参数。
- `gets_s()`读到换行符，会丢弃它，不进行保存。
- `gets_s()`如果读到最大字符串，都没有读到换行符。它会将目标数组的第一个字符设为 null 字符，读取并丢弃随后的输入，直至读到换行符或文件结尾，然后返回空指针。接着，调用处理函数，可能会中止或退出程序。

## Stream

文件必须先打开，才能读取或写入。

C 语言提供三个默认已经打开的文件。

- stdin	标准输入，通常默认情况下为键盘
- stdout	标准输出，通常默认情况下为屏幕
- stderr	标准错误，通常也是默认情况下的屏幕

下面两种写法是等价的。

```c
printf("Hello, world!\n");
fprintf(stdout, "Hello, world!\n");
```

`printf()`是直接写入`stdout`，而`fprint`是指定写入文件`stdout`。

## 其他 I/O 函数

int ungetc(int c, FILE *fp)

int ungetc()函数把c指定的字符放回输入流中。如果把一个字符放回输入流，下次调用标准输入函数时将读取该字符。

ANSI C标准保证每次只会放回一个字符。如果实现允许把一行中的多个字符放回输入流，那么下一次输入函数读入的字符顺序与放回时的顺序相反。

int fflush(FILE *fp);

调用fflush()函数引起输出缓冲区中所有的未写入数据被发送到fp指定的输出文件。这个过程称为刷新缓冲区。如果 fp是空指针，所有输出缓冲区都被刷新。

