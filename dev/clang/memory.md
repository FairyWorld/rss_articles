# C 语言的内存管理

## 简介

C 语言的内存管理，分成两部分。一部分是系统管理的，另一部分是用户手动管理的。

系统管理的内存，主要是函数内部的变量（local 的变量）。这部分变量在函数运行时进入内存，函数运行结束后自动从内存卸载。这些变量存放的区域称为”栈“（stack），”栈“所在的内存是系统自动管理的。

用户手动管理的内存，主要是程序运行的整个过程中都存在的变量（全局变量），这些变量需要用户手动从内存释放。如果使用后忘记释放，它就一直占用内存，直到程序退出，这种情况称为”内存泄漏“（memory leak）。这些变量所在的内存称为”堆“（heap），”堆“所在的内存是用户手动管理的。

## 内存管理函数

C 语言内存管理的函数原型，都是在`<stdlib.h>`定义，使用这些函数之前，需要先加载这个头文件。

### malloc()

`malloc()`函数用于分配内存，可以在 heap 里面分配连续的内存块。该函数的原型定义在头文件`stdlib.h`里面。

它接受一个 size_t 类型的整数作为参数，表示所要分配的内存块的字节数，返回一个 void 指针，指向分配好的内存块。如果分配没有成功，返回 NULL。

```c
void* malloc(size_t size)
```

由于返回的是 void 指针，所以可以使用`malloc()`为任何类型的数据分配内存。常见的做法是先使用`sizeof()`函数，算出数据类型的字节长度，然后再将这个长度传给`malloc()`。

```c
int* p = malloc(sizeof(int));

*p = 12;
printf("%d\n", *p); // 12
```

上面示例为一个整数指针分配内存，然后将整数`12`放入分配到的内存里面。这个例子其实不需要使用`malloc()`，因为 C 语言会自动为整数（本例是`12`）提供内存。

为了增加代码的可读性，最好还是对`malloc()`返回的指针进行一次强制类型转换。

```c
int* p = (int*) malloc(sizeof(int));
```

上面代码将`malloc()`返回的 void 指针，强制转换成了整数指针。

由于`sizeof()`的参数可以是变量，所以上面的例子也可以写成下面这样。

```c
int* p = (int*) malloc(sizeof *p);
```

`malloc()`最常用的场合，就是为数组和自定义数据结构分配内存。

```c
int* p = (int*) malloc(sizeof(int) * 10);

for (int i = 0; i < 10; i++)
  p[i] = i * 5;
```

上面示例中，`p`只是一个整数指针，由于分配了足够的内存（可以放置10个整数），就能用作数组。

`malloc()`用来创建数组，有一个好处，就是它可以创建动态数组，即根据成员数量的不同，而创建长度不同的数组。

```c
int* p = (int*) malloc(n * sizeof(int));
```

上面示例中，`malloc()`可以根据变量`n`的不同，动态为数组分配不同的大小。

`malloc()`可能由于内存不足而分配失败，所以调用后，最好检查一下是否分配成功。

```c
int* x;

x = malloc(sizeof(int) * 10);

if (x == NULL) {
  printf("Error allocating 10 ints\n");
}
```

### free()

`malloc()`分配的内存，使用完毕后，必须使用`free()`手动释放，将这块内存还给 Heap 以便重新使用，否则会一直占用到程序运行结束。

`free()`的参数是`malloc()`返回的内存地址。该函数的原型定义在头文件`stdlib.h`里面。

```c
void free(void* block)
```

下面是一个例子。

```c
int* p = (int*) malloc(sizeof(int));

*p = 12;
free(p);
```

注意，分配的内存块一旦释放，就不应该再次操作已经释放的地址，也不应该再次使用`free()`对该地址释放第二次。

一个很常见的错误是，在函数内部分配了内存，但是函数调用结束时，没有使用`free()`释放内存。

```c
void gobble(double arr[], int n) {
  double* temp = (double*) malloc(n * sizeof(double));
  // ...
}
```

上面示例中，函数`gobble()`内部分配了内存，但是没有写`free(temp)`。这会造成函数运行结束后，占用的内存块依然保留，如果多次调用`gobble()`，就会留下多个内存块。并且由于指针`temp`已经消失了，也无法访问这些内存块，进行重复使用。

## calloc()

`calloc()`的作用与`malloc()`相似，也是分配内存块。两者的区别主要有两点：

（1）`calloc()`接受两个参数，第一个参数是数据类型的单位字节长度，第二个是该数据类型的数量。

（2）`calloc()`会将所分配的内存全部初始化为`0`。`malloc()`不会对内存进行初始化，必须额外调用`memset()`函数。

```c
int *p = calloc(10, sizeof(int));

// 等同于
int *q = malloc(sizeof(int) * 10);
memset(q, 0, sizeof(int) * 10);
```

`calloc()`的返回值也是一个 void 指针。分配失败时，返回 NULL。

`calloc()`分配的内存块，也使用`free()`释放。

### realloc()

`realloc()`函数用于修改已经分配的内存块的大小，可以放大也可以缩小，返回一个指向新的内存块的指针。如果分配不成功，返回 NULL。

```c
void* realloc(void* block, size_t size)
```

它接受两个参数，第一个是指向已经分配好的内存块的指针（由`malloc()`或`calloc()`产生），第二个该内存块的新大小，单位为字节数量，而不是成员的数量。它可能返回一个全新的指针（数据也会自动复制过去），也可能返回跟原来一样的指针。

下面是一个例子，`b`是数组指针，`realloc()`动态调整它的大小。

```c
int* b;

b = malloc(sizeof(int) * 10);

b = realloc(b, sizeof(int) * 2000);
```

上面示例中，指针`b`原来指向10个成员的整数数组，使用`realloc()`调整为2000个成员的数组。这就是手动分配数组内存的好处，可以在运行时随时调整数组的长度。

`realloc()`的第一个参数可以是 NULL，这时就相当于新建一个指针。

```c
char* p = realloc(NULL, 3490);
// 等同于
char *p = malloc(3490);
```

由于有分配失败的可能，所以调用`realloc()`以后，最好检查一下它的返回值是否为 NULL。

```c
float *new_p = realloc(p, sizeof *p * 40);

if (new_p == NULL) {
  printf("Error reallocing\n");
  return 1;
}
```

