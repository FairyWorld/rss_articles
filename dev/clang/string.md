# 字符串

## 简介

C 语言没有单独的字符串类型，字符串被当作字符数组，即`char`类型的数组。比如，字符串“Hello”是当作数组`{'H', 'e', 'l', 'l', 'o'}`处理的。

编译器会给数组分配一段连续内存，所有字符储存在相邻的内存单元之中。在字符串结尾，C 语言会自动添加`\0`字符（即数组的最后一个成员是`\0`），表示字符串结束。所以字符串“Hello”实际储存的数组是`{'H', 'e', 'l', 'l', 'o', '\0'}`。

这样做的好处是，C 语言不需要知道长度，就可以读取内存里面的字符串，只要发现有一个字符是`\0`，那么就知道字符串结束了。

```c
char localString[10];
```

上面示例声明了一个10个成员的字符数组，即长度为10的数组。由于必须留一个位置给`\0`，所以最多只能容纳长度为9的字符串。

注意，`\0`不是字符`0`（ASCII 码 48），也不是字符空白符（ASCII 码 32），而是二进制位都设为`0`的一个标记，表示 NULL（空）。`\0`不用自己设置，C 语言会在生成字符串的时候自动添加。

C 语言约定，字符串必须放在双引号里面，以便跟字符类型的值区分。字符类型的值只能放在单引号里面。

```c
"This is a test."
```

即使在双引号里面只有一个字符（比如`"a"`），也依然被处理成字符串（长度为2），而不是字符`'a'`（长度为1）。

如果字符串内部包含双引号，则该双引号需要使用反斜线转义。

```c
"She replied, \"It does.\""
```

字符串内部允许包含特殊字符，比如表示换行的`\n`。

```c
"Hello, world!\n"
```

使用双引号，声明字符串变量也可以写成下面这样。

```c
char* s = "Hello, world!";

// 等同于
char s[14] = "Hello, world!";
```

上面示例中，变量`s`其实是指向第一个字符`H`的指针。

字符数组的长度可以留给编译器自动计算，所以声明时可以不给出字符数组的长度。

```c
char s[] = "Hello, world!";
```

声明字符串变量的两种方法（指针和数组），有一个细微的差异。指针指向的字符串，在 C 语言内部被当作常量，不能修改字符串本身。

```c
char* s = "Hello, world!";
s[0] = 'z';
```

上面代码使用指针，声明了一个字符串变量，然后修改了字符串的第一个字符。这种写法是错的，会导致难以预测的后果，执行时很可能会报错。

如果使用数组声明字符串变量，就没有这个问题，可以修改数组的任意成员。

```c
char s[] = "Hello, world!";
s[0] = 'z';
```

为什么字符串声明为指针时不能修改，声明为数组时就可以修改？原因是声明为指针时，字符串是一个保存在内存“栈区”（stack）的常量，“栈区”的值由系统管理，一般都不允许修改；声明为数组时，字符串的副本会被拷贝到内存“堆区”（heap），“堆区”的值由用户管理，是可以修改的。

如果字符串字面量之间没有间隔，或者只有空格，C 语言会将它们自动合并。

```c
char greeting[50] = "Hello, ""how are you ""today!";
// 等同于
char greeting[50] = "Hello, how are you today!"
```

## strlen()

C 语言提供了一个`strlen()`函数，返回字符串的字符长度，不包括末尾的空字符`\0`。

```c
char* str = "hello";
int len;
len = strlen(str); // 5
```

`strlen()`的原型在标准库的`string.h`文件中定义，使用时需要加载头文件`string.h`。

```c
#include <stdio.h>
#include <string.h>

int main(void) {
  char* s = "Hello, world!";
  printf("The string is %zd characters long.\n", strlen(s));
}
```

`strlen()`函数返回值的类型是`size_t`，跟`sizeof`的返回值类型一致。

如果不使用这个函数，可以通过判断字符串末尾的`\0`，自己计算字符串长度。

```c
int my_strlen(char *s) {
  int count = 0;
  while (s[count] != '\0')
    count++;
  return count;
}
```

## strcat()

`strcat()`函数用于拼接字符串。它接受两个字符串作为参数，把第二个字符串的副本添加到第一个字符串的末尾。这个函数会改变第一个字符串，但是第二个字符串不变。

`strcat()`的返回值是一个字符串指针，指向第一个参数。

```c
char s1[12] = "hello";
char s2[6] = "world";

strcat(s1, s2);
puts(s1); // "helloworld"
```

上面示例中，调用`strcat()`以后，可以看到字符串`s1`的值变了。

该函数的原型定义在`string.h`头文件里面。

## strncat()

`strcat()`函数有一个问题，就是需要使用者自己保证，第一个字符串数组的长度能够容纳连接后的第二个字符串。如果第一个字符串数组的长度不够，就会产生溢出问题，影响到相邻的内存单元，这是很危险的。

`strncat()`函数可以解决这个问题，它的第三个参数指定了最大添加的字符数。一旦发现，拼接的第二个字符串到达这个数量，或者遇到空字符，就不再拼接了。

```c
char s1[10] = "Monday";
char s2[8] = "Tuesday";

strncat(s1, s2, 3);
puts(s1); // "MondayTue"
```

上面示例中，`strncat()`的第三个参数指定只能添加三个字符，所以得到的结果是`MondayTue`。

该函数的原型定义在`string.h`头文件里面。

## strcmp()

`strcmp()`函数用于比较两个字符串的内容。如果两个字符串相同，返回值为`0`，否则返回非零值。

```c
char s1[12] = "hello";
char s2[6] = "world";

if (strcmp(s1, s2) != 0) {
  printf("They are different.\n");
}
```

上面示例中，两个字符串不相等，就会输出一行提示信息。注意，这个例子中两个字符串数组的长度是不一样的，`strcmp()`并不考虑数组长度，只比较字符串内容是否一致。

此外，`strcmp()`只用来比较字符串，不用来比较字符。因为字符就是小整数，直接用相等运算符（`==`）就能比较。所以，不要把字符类型的值，放入`strcmp()`当作参数。

该函数的原型定义在`string.h`头文件里面。

## strncmp()

`strcmp()`用于比较整个字符串，直到发现不同的字符位置，比较过程会一直持续到字符串的末尾。

`strncmp()`函数则是只比较到指定的位置。它的第三个参数指定了比较的字符数。

```c
char s1[12] = "hello world";
char s2[12] = "hello C";

if (strncmp(s1, s2, 5) == 0) {
  printf("They all have hello.\n");
}
```

上面示例只比较两个字符串的前5个字符。

该函数的原型定义在`string.h`头文件里面。

## strcpy()

`strcpy()`函数用于将一个字符串的内容，复制到另一个字符串，相当于字符串赋值。该函数的原型定义在`string.h`头文件里面。

```c
strcpy(char dest[], char source[])
```

`strcpy()`接受两个参数，第一个参数是目的字符串数组，第二个参数是源字符串数组。复制字符串之前，必须要保证第一个参数的长度不小于第二个参数。

```c
#include <stdio.h>
#include <string.h>

int main(void) {
  char s[] = "Hello, world!";
  char t[100];

  strcpy(t, s);

  t[0] = 'z';
  printf("%s\n", s);  // "Hello, world!"
  printf("%s\n", t);  // "zello, world!"
}
```

上面示例将变量`s`的值，拷贝一份放到变量`t`，变成两个不同的字符串，修改一个不会影响到另一个。另外，变量`t`的长度大于`s`，复制后多余的位置（结束标志`\0`后面的位置）都为随机值。

`strcpy()`的返回值是一个字符串指针（即`char*`），指向第一个参数。

```c
char* s1 = "beast";
char s2[40] = "Be the best that you can be.";
char* ps;

ps = strcpy(s2 + 7, s1);

puts(s2); // Be the beast
puts(ps); // beast
```

上面示例中，从`s2`的第7个位置开始拷贝字符串`beast`，前面的位置不变。这导致`s2`后面的内容都被截去了，因为会连`beast`结尾的空字符一起拷贝。`strcmp()`返回的是一个指针，指向拷贝开始的位置。

注意，如果使用赋值运算符（`=`）复制字符串，得到的是两个指向同一字符串的指针。修改其中任何一个，都会影响到另一个。

另外，`strcpy()`的第一个参数最好是一个已经声明的数组，而不是声明后没有进行初始化的字符指针。

```c
char* str;
strcpy(str, "hello world");
```

上面的代码是有问题的。`strcpy()`将字符串分配给指针变量`str`，但是`str`并没有进行初始化，指向的是一个随机的位置，因此字符串可能被复制到任意地方。这是因为，声明数组时 C 语言就会分配储存数据的空间，而声明指针时只分配了储存内存地址的空间，并没有设定指向哪一个地址。

## strncpy()

`strcpy()`并不检查目标字符串能否容纳源字符串的副本，所以使用`strncpy()`更保险一点，该函数的第3个参数指定拷贝的最大字符数。

```c
char s1[40];
char s2[12] = "hello world";

strncpy(s1, s2, 5);
s1[5] = '\0';

puts(s1); // hellost
```

上面示例中，指定只拷贝前5个字符。注意，`strncpy()`不会自己添加字符串结尾标志，如果截取的字符串片段不包含结尾标志，就需要手动添加。

## sprintf()

`sprintf()`函数跟`printf()`类似，但是用于将数据写入字符串，而不是输出到显示器。该函数的原型定义在`stdio.h`头文件里面。

`sprintf()`的第一个参数是目标字符串的地址，其余参数和`printf()`相同，即第二个参数是格式字符串，后面的参数是待写入的变量列表。

```c
char first[6] = "hello";
char last[6] = "world";
char s[40];

sprintf(s, "%s %s", first, last);

puts(s); // hello world
```

## 其他字符串函数

char *strchr(const char * s, int c);

如果s字符串中包含c字符，该函数返回指向s字符串首位置的指针（末尾的空字符也是字符串的一部分，所以在查找范围内）；如果在字符串s中未找到c字符，该函数则返回空指针。

char *strpbrk(const char * s1, const char * s2);

如果 s1 字符中包含 s2 字符串中的任意字符，该函数返回指向 s1 字符串首位置的指针；如果在s1字符串中未找到任何s2字符串中的字符，则返回空字符。

char *strrchr(const char * s, int c);该函数返回s字符串中c字符的最后一次出现的位置（末尾的空字符也是字符串的一部分，所以在查找范围内）。如果未找到c字符，则返回空指针。

char *strstr(const char * s1, const char * s2);

该函数返回指向s1字符串中s2字符串出现的首位置。如果在s1中没有找到s2，则返回空指针。

## 转义序列

- \a 响铃
- \b 退格
- \n 换行符
- \t 水平制表符
- \" 双引号
- \\ 斜杠
