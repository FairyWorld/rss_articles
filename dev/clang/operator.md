# 运算符

C 语言的运算符非常多，一共有 50 多种，可以分成若干类。

## 算术运算符

算术运算符专门用于算术运算，主要有下面几种。

- `+`：一元的正值运算符
- `-`：一元的负值运算符
- `+`：加法运算符
- `-`：减法运算符
- `*`：乘法运算符
- `/`：除法运算符
- `%`：余值运算符

（1）`+`，`-`

`+`和`-`既可以作为一元运算符，也可以作为二元运算符。所谓“一元运算符”，指的是只需要一个运算数就可以执行。一元运算符`-`用来改变一个值的正负号。

```c
int x = -12;
```

上面示例中，`-`将`12`这个值变成`-12`。

一元运算符`+`对正负值没有影响，是一个完全可以省略的运算符，但是写了也不会报错。

```c
int x = -12;
int y = +x;
```

上面示例中，变量`y`的值还是`-12`，因为`+`不会改变正负值。

二元运算符`+`和`-`用来做加法和减法。

```c
int x = 4 + 22;
int y = 61 - 23;
```

（2）`*`

运算符`*`表示乘法。

```c
int num = 5;
printf("%i\n", num * num);
```

（3）`/`

运算符`/`表示除法。注意，两个整数相除，得到还是一个整数。

```c
float x = 6 / 4;
printf("%f\n", x); // 输出 1.000000
```

上面示例中，尽管变量`x`的类型是`float`，但是`6 / 4`得到的结果是`1.0`，而不是`1.5`。原因就在于 C 语言里面的整数除法是整除，只会返回整数部分，丢弃小数部分。

如果希望得到浮点数的结果，只需要让两个运算数里面，至少有一个浮点数即可，这时 C 语言会确保两个运算数都是浮点数，然后进行浮点数除法。

```c
float x = 6.0 / 4; // 或者写成 6 / 4.0
printf("%f\n", x); // 输出 1.500000
```

（4）`%`

运算符`%`表示求模运算，即返回两个整数相除的余值。这个运算符只能用于整数，不能用于浮点数。

```c
int x = 6 % 4; // 2
```

负数求模的规则是，结果的正负号由第一个运算数的正负号决定。

```c
11 % -5 // 1
-11 % -5 // -1
-11 % 5 // -1
```

上面示例中，第一个运算数的正负号（`11`或`-11`）决定了结果的正负号。

（5）赋值运算的简写形式

如果变量对自身的值进行算术运算，C 语言允许将赋值运算符和算术运算符结合在一起，提供简写形式。

- `+=`：加法赋值运算符
- `-=`：减法赋值运算符
- `*=`：乘法赋值运算符
- `/=`：除法赋值运算符
- `%=`：余值赋值运算符

下面是一些例子。

```c
i += 3;  // 等同于 i = i + 3
i -= 8;  // 等同于 i = i - 8
i *= 9;  // 等同于 i = i * 9
i /= 2;  // 等同于 i = i / 2
i %= 5;  // 等同于 i = i % 5
```

## 自增运算符，自减运算符

C 语言提供两个运算符，对变量自身进行`+ 1`和`- 1`的操作。

- `++`：自增运算符
- `--`：自减运算符

```c
i++; // 等同于 i = i + 1
i--; // 等同于 i = i - 1
```

这两个运算符放在变量的前面或后面，结果是不一样的。`++var`和`--var`是先执行自增或自减操作，再返回操作后`var`的值；`var++`和`var--`先返回操作前`var`的值，再执行自增或自减操作。

```c
int i = 42;
int j;

j = (i++ + 10);
// i: 43
// j: 52

j = (++i + 10)
// i: 44
// j: 54
```

上面示例中，自增运算符的位置，会导致变量`j`得到不同的值。这样的写法很容易出现意料之外的结果，为了消除意外，可以改用下面的写法。

```c
/* 写法一 */
j = (i + 10);
i++;

/* 写法二 */
i++;
j = (i + 10);
```

上面示例中，变量`i`的自增运算与返回值是分离的两个步骤，这样就不太会出错，也提高了代码的可读性。

## 关系运算符

C 语言里面，用于比较的表示式，称为“关系表达式”（relational expression），里面使用的运算符就称为“关系运算符”（relational operator），主要有下面这些。

- `>` 大于运算符
- `<` 小于运算符
- `>=` 大于等于运算符
- `<=` 小于等于运算符
- `==` 等于运算符
- `!=` 不等于运算符

下面是一些例子。

```c
a == b;
a != b;
a < b;
a > b;
a <= b;
a >= b;
```

关系表达式通常返回`0`或`1`，表示真假。C 语言中，`0`表示假，所有非零值表示真。比如，`20 > 12`返回`1`，`12 > 20`返回`0`。

关系表达式常用于`if`或`while`结构。

```c
if (x == 3) {
  printf("x is 3.\n");
}
```

注意，等号`=`不是比较运算符，不要跟`==`混淆。有时候，不小心会写出下面的代码，它可以运行，但很容易出现意料之外的结果。

```c
if (x = 3) ...
```

为了防止出现这种错误，有的程序员喜欢将变量写在等号的右边。

```c
if (3 == x) ...
```

这样的话，如果把`==`误写成`=`，编译器就会报错。

```c
/* 报错 */
if (3 = x) ...
```

## 逻辑运算符

- `!` 否运算符
- `&&` 与运算符
- `||` 或运算符

```c
if (x < 10 && y > 20)
  printf("Doing something!\n");
```

下面是否运算符的例子。

```c
if (!(x < 12))
  printf("x is not less than 12\n");
```

上面示例中，由于否运算符`!`具有比`<`更高的优先级，所以必须使用括号。

对于逻辑运算符来说，任何非零值都是真值，任何零值都是假值。比如，`5 || 0`会返回`1`，`5 && 0`会返回`0`。

## 位运算符

- `~a` 否运算，a 的所有位都取反（将 0 变为 1，将 1 变为 0）。
- `a & b`：与运算（and）。
- `a | b` 位的或运算（or）。
- `a ^ b` 位的异或运算（exclusive or）。
- `>>` 位的右移运算（right shift，除以 2 的乘方)。
- `<<` 位的左移运算（left shift，乘以 2 的乘方)。

注意，不要把位运算符`&`和`|`，跟逻辑运算符`&&`和`||`混淆。

位运算符的优先级很高，比布尔运算符更高。

赋值运算符的简写。

`x += 2`等于`x = x + 2`。

- `+=`, `-=` 加法赋值、减法赋值。
- `*=`, `/=` 乘法赋值、除法赋值。
- `%=` 整除赋值。
- `>>=` 右移运算赋值。
- `<<=` Bitwise left shift RHS (multiply by power of 2)
- `&=`, `|=`, `^=` Bitwise and, or, xor by RHS

## 逗号运算符

逗号运算符用于将多个表达式写在一起，从左到右依次运行每个表达式。

```c
x = 10, y = 20;
```

上面示例中，有两个表达式（`x = 10`和`y = 20`），逗号使得它们可以放在同一条语句里面。

逗号运算符返回最后一个表达式的值，作为整个语句的值。

```c
x = 1, 2, 3;
```

上面示例中，逗号的优先级高于赋值运算符，所以会执行。由于逗号运算符返回最后一个表达式的值，所以变量`x`等于`3`。

## 运算优先级

各种运算符的优先级是不一样的。

```c
int x = 3 + 4 * 5;
```

上面示例中，既有加法运算符（`+`），又有乘法运算符（`*`）。由于乘法的优先级高于加法，所以会先计算`4 * 5`，而不是先计算`3 + 4`。

如果两个运算符优先级相同，则根据运算符是左结合，还是右结合，决定执行顺序。大部分运算符是左结合（从左到右执行），少数运算符是右结合（从右到左执行），比如赋值运算符（`=`）。

```c
int x = 5 * 6 / 2;
```

上面示例中，`*`和`-`的优先级相同，它们都是左结合运算符，所以从左到右执行，先计算`5 * 6`，再计算`6 / 2`。

运算符的优先级顺序很复杂。下面是部分运算符按照优先级从高到低排列。

- 圆括号（`()`）
- 自增运算符（`++`），自减运算符（`--`）
- 一元运算符（`+`和`-`）
- 乘法（`*`），除法（`/`）
- 加法（`+`），减法（`-`）
- 关系运算符（`<`、`>`等）
- 赋值运算符（`=`）

由于圆括号的优先级最高，可以使用它改变其他运算符的优先级。

```c
int x = (3 + 4) * 5;
```

上面示例中，由于添加了圆括号，加法会先于乘法进行运算。

完全记住所有运算符的优先级不现实，为了提高代码的可读性，防止出现意料之外的情况，建议多用圆括号，也便于保证优先级跟预期的一致。

