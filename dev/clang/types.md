# 数据类型

C 语言的数据是有类型（type）的。所谓”类型”，就是编译器解释二进制数据的方式。

基本数据类型有三种：字符（char）、整数（int）和浮点数（float）。其他复杂的类型都是基于它们构建的。

## 字符类型

字符类型指的是单个字符，类型声明使用`char`关键字。

```c
char c = 'B';
```

上面示例声明了变量`c`是字符类型，并将其赋值为字母`B`。

C 语言规定，字符常量必须放在单引号里面。

在计算机内部，字符类型使用一个字节（8个二进制位）储存。C 语言将其当作整数处理，即字符类的整数范围是`0`到`255`，每个字符对应一个整数（由 ASCII 码确定），比如`B`对应整数`66`。由于这个原因，一些小整数（小于256的整数）也可以赋值给字符类型。

```c
char c = 66;
```

上面示例中，变量`c`是字符类型，但是赋给它的值是整数66。实际上，这跟赋值为字符`B`的效果是一样的。

两个字符类型的变量可以进行数学运算。

```c
char a = 'B'; // 等同于 char a = 66;
char b = 'C'; // 等同于 char b = 67;

printf("%d\n", a + b); // 输出 133
```

上面示例中，占位符`%d`表示输出十进制整数，因此变量`a`和`b`相加，就是两个整数相加。

单引号本身也是一个字符，如果要引用这个字符，必须使用反斜杠转义。

```c
char t = '\'';
```

上面示例中，变量`t`等于单引号字符，由于字符类型的定义必须放在单引号里面，所以内部的单引号要使用反斜杠转义。

反斜杠还能用来表示 ASCII 码定义的一些控制字符，它们也属于字符类型的值。

- `\a`：警报，这会使得终端发出警报声或出现闪烁，或者两者同时发生。
- `\b`：退格键，光标回退一个字符，但不删除字符。
- `\f`：换页符，光标移到下一页。在现代系统上，这已经反映不出来了，行为改成类似于`\v`。
- `\n`：换行符。
- `\r`：回车符，光标移到同一行的开头。
- `\t`：制表符，光标移到下一个水平制表位，通常是下一个8的倍数。
- `\v`：垂直分隔符，光标移到下一个垂直制表位，通常是下一行的同一列。
- `\0`：null 字符，代表没有内容。注意，这个不代表数字0，是当作字符解读。

注意，上面这些值都要放在单引号里面。

## 整数类型

整数类型用来表示较大的整数，类型声明使用`int`关键字。

```c
int a;
```

上面示例声明了一个整数变量`a`。

目前来说，计算机内部对整数类型的值，至少使用4个字节（32个二进制位）储存，也可能使用8个字节（64个二进制位）储存。如果是8个字节的话，可以表示的数值范围为`-9,223,372,036,854,775,808`到`9,223,372,036,854,775,807`。

整数类型默认是带有正负号的（signed），既包括正数，也包括负数。`signed`这个类型修饰词默认可以省略。

```c
int a;
// 等同于
signed int a;
```

也可以把整数类型声明为不带符号的（unsigned），即只能为正数。这样的话，同样长度的内存能够表示的整数值，可以增大一倍，从`0`到`18,446,744,073,709,551,615`。

```c
unsigned int a;
```

8个字节表示的整数有点浪费空间，平时经常使用的都是一些较小的整数，用不到8个字节。C 语言提供三个修饰词，可以更精细地表示整数的范围：`short`、`long`、`long long`。

- `short`：一般为2个字节的整数。
- `long`：一般为4个字节的整数。
- `long long`：一般为8个字节的整数。

```c
short int a;
long int b;
long long int c;
```

默认情况下，`short`、`long`、`long long`都是带符号的（signed），也可以将它们声明为不带符号（unsigned），使得能够表示的最大值扩大一倍。

```c
unsigned short int a;
unsigned long int b;
unsigned long long int c;
```

C 语言允许省略`int`，所以上面的语句也可以写成下面这样。

```c
short a;
unsigned short a;

long b;
unsigned long b;

long long c;
unsigned long long c;
```

字符类型`char`其实也有带符号和不带符号之分。

```c
signed char c; // 一般为默认值，范围为 -127 到 0
unsigned char c; // 整数值范围为 0 到 255
```

## 浮点数

浮点数主要用来表示小数，使用`float`表示。

```c
float c;
```

C 语言提供三种浮点数类型，使用不同数量的字节进行储存，提供不同的精度。

- `float`：单精度浮点数，提供6位精度，通常是4个字节（32个二进制位）。
- `double`：双精度浮点数，提供15位精度，通常是8个字节（64个二进制位）。
- `long double`：字节宽度更大的浮点数，通常是16个字节。

C 语言编译器自动将小数（比如`3.14`）当作双精度浮点数。如果想把小数指定为其他类型，需要在小数后面添加后缀`f`（float）或`l`（long double）。

这里需要注意，浮点数的计算是不精确的。

C 语言允许使用科学计数法表示浮点数。

```c
double x = 123.456e+3; // 123456
```

`e`后面的加号`+`可以省略，但是不建议这样写。


```c
1.2345e10 == 1.2345e+10
```

## 布尔值

C 语言没有布尔值类型，`0`被当成`false`，所有非零值被当成`true`。

```c
i = 0;
while (i - 10) {
// ...
```

上面代码中，只要`i - 10`不等于`0`，C 语言就认为判断为真，从而执行循环体。

## 常量

C 语言编译器读到数字时（比如`123`），默认会把数字当作整数类型（`int`）。

如果需要编译器将这些值处理成其他类型，就需要使用后缀来表示。

```c
int           x = 1234;
long int      x = 1234L;
long long int x = 1234LL

unsigned int           x = 1234U;
unsigned long int      x = 1234UL;
unsigned long long int x = 1234ULL;
```

- int	没有
- long int	L
- long long int	LL
- unsigned int	U
- unsigned long int	UL
- unsigned long long int	ULL

如果数字加上`L`后缀（比如`123L`，大小写都可），则会把数字解析为长整数类型（`long int`）。

浮点数常量默认会被当作双精度类型`double`，也可以使用后缀指定类型。

- float	F
- double	没有
- long double	L

```c
float x       = 3.14f;
double x      = 3.14;
long double x = 3.14L;
```

科学计数法可以使用后缀。

```c
1.2345e+10F
1.2345e+10L
```

## 整数的进制

整数常量不仅可以是十进制，也可以是其他进制（比如八进制和十六进制）。

八进制使用`0`作为前缀，比如`017`、`0377`。

```c
int a = 012;
```

十六进制使用`0x`作为前缀，比如`0xf`、`0xff`。

```c
int a = 0x1A2B;
```

有些编译器使用`0b`前缀，表示二进制数。

```c
int x = 0b101010;
```

## 编译器的自动类型判断

对于整数常量，编译器会自动将它处理为`int`类型。如果常量的值太大，无法放入`int`，就用`long int`类型。如果还是太大，则使用`unsigned long int`类型。

如果想让编译器直接将整数常量作为长整数处理，只需在后面加上一个字母`L`或`l`。比如，`15L`、`0377L`、`0x7fffL`。

为了指明是无符号常量，可以在常量后面加上字母`U`或`u`。比如，`15U`、`0377U`。

`L`和`U`可以结合使用，表示常量既是长整型又是无符号的。比如`0xfffffffUL`。（字母`L`和`U`的顺序和大小写无所谓。）

字母`LL`或`ll`，表示整数常量是`long long int`类型。

对于浮点数，编译器默认以双精度储存。如果要以单精度储存，浮点数常量的后面要添加`F`或`f`。如果要以`long double`储存，要添加`L`或`l`。

## 类型的自动转换

不同类型的值进行混合计算时，必须先转成同一个类型，才能进行计算。转换规则如下：

- 表达式中有一个值是浮点类型时，其他值转为浮点类型。
- 表达式中的值是不同类型的整数类型时（比如`short`和`int`的计算），较短的类型会提示为较长的类型。有时还会将带符号的类型`signed`转为无符号`unsigned`。

### 转换为整数

如果`char`或`short`类型赋值给`int`类型，会自动提升为`int`。

```c
char x = 10;
char y = 20;
int i = x + y;
```

上面示例中，`x + y`运算结果的类型是`char`，由于赋值给`int`，所以会自动提升为`int`。

`int`与`float`的计算，得到的结果会转为`int`。

```c
int x = 3 + 1.2; // 4.2 会转为 4
```

宽度较小的值，允许转化成宽度较大的值。

```c
short x = 15;
int y = x;
```

宽度较大的值，转换成宽度较小的值，会发生溢出，导致难以预料的结果。

```c
int x = 100000;
short y = x;
printf("y is %hi\n", y); // -31072
```

上面代码中，变量`x`是`int`类型，宽度为8个字节；变量`y`是`short`类型，宽度为2个字节。`100000`这个值对于`short`类型太大了，会发生溢出，导致变量`y`的值不是`10000`，而是`-31072`（截去高位后剩下的值）。

### 转换为浮点数

整数运算结果会自动转为浮点数。

```c
float y = 12 * 2; // 24 转为 24.0
```

下面示例的运算结果是`3.0000`。

```c
int x = 7;
int y = 2;
float z = x / y;
printf("z = %f\n", z);
```

如果希望得到正确的结果，必须将整数强制转为浮点数以后，再进行除法运算。

```c
float z = (float)x / (float)y;
```

事实上，如果编译器发现整数与浮点数进行加、减、乘、除运算，会自动将整数转为浮点数。因此，写成下面这样也可以。

```c
float z = (float)x / y;
```

### void* 指针

其他所有类型指针都可以转为`void*`指针，而`void*`指针也可以转为其他类型的指针。

```c
int x = 10;

void* p = &x; // &x 是 int 指针，转为 void* 指针

int *q = p; // p 是 void* 指针，转为 int 指针
```

## 类型的显式转换

在一个值的前面，使用圆括号添加新的类型名称，可以将这个值手动转为另一个类型。

```c
int x = 10;
long int y = (long int) x + 12;
```

上面示例在变量`x`前面加上`(long int)`，显式将它转为`long int`类型。这个例子纯粹是为了说明，这里其实不必使用显式转换，C 语言自动会更改`x + 12`的类型为`long int`。

## 变量的截值（Truncation）

截值（Truncation）指的是将一个值，从较宽的类型变为较窄的类型。多出来的比特位，将被自动截去。

```javascript
char ch;
int i;

i = 321;
ch = i; // ch 的值是 65 （321 - 256）
```

上面例子中，变量`ch`的长度是8个二进制位，只能容纳变量`i`（16个二进制位）的后八位。`321`的二进制形式是`101000001`，保留后八位就变成了`01000001`（十进制的65，相当于字符`A`）。

浮点数赋值给整数类型的值，小数部分会被截去。

```c
double pi;
int i;

pi = 3.14159;
i = pi; // i 的值为 3
```

为了避免这个问题，整数运算时，有时可能需要明确将类型转为浮点数。

```c
int score;
score = 5;

score = (score / 20) * 100;
```

上面的代码，你可能觉得经过运算，`score`会等于`25`，但是实际上`score`等于`0`。这是因为`score / 20`会得到一个整数值，即`0`，所以乘以`100`后得到的也是`0`。

为了得到预想的结果，可以采用下面两种写法，将`score`显式或非显式地转为浮点数。

```c
/* 写法一 */
score = ((double)score / 20) * 100;

/* 写法二 */
score = (score / 20.0) * 100;
```

## sizeof 运算符

`sizeof`运算符接受一个变量名作为参数，返回该变量占用的字节数量。

除了`char`类型的变量始终为一个字节，其他类型的变量在不同的系统上，占用的字节数量可能会有所不同。

```c
int a = 999;


sizeof a; // 4
sizeof(2 + 7); // 4
sizeof 3.14; // 8
```

也可以直接对各种类型名使用`sizeof`运算符，这时类型名必须放在括号里面。

```c
sizeof(int); // 4
sizeof(char); // 1
```

## 类型限定词

类型声明之前，可以加上限定词，用来精细控制变量的行为。

### const

限定词`const`表示该变量是常量，赋值时就不能再修改值。

```c
const int x = 2;
x = 4; // 编译器报错
```

涉及指针时，`const`有两种含义。

第一种含义是不能修改指针指向的值，这时要将`const`放在最前面。

```c
int x[] = {10, 20};
const int* p = x;

p++; // 可以修改
*p = 30; // 报错，不可以修改
```

上面示例中，`const int*`表示指针指向的整数值是常量，不能修改，但是指针变量储存的地址是可以修改。

第二种含义是不能修改指针变量储存的地址，这时`const`要放在星号`*`后面。

```c
int x[] = {10, 20};
const int* p = x;

p++; // 报错，不可以修改
*p = 30; // 可以修改
```

可以同时使用两个`const`，既不可以修改指针指向的值，也不能修改指针变量储存的地址。

```c
const int* const p;
```

### restrict

`restrict`告诉编译器，该块内存只能由一个指针访问，不能让另一个指针访问。

### volatile

`volatile`告诉编译器，某个值可能会发生变化，每次使用时都应该进行查询。

```c
volatile int *p;
```

### auto

`auto`是块作用域变量的默认值，表示该变量会存在与定义时所在的作用域，退出作用域时会自动释放。

```c
{
  int a;
  auto int a;
}
```

### static

`static`修饰词在块作用域里面，表示该变量只需要初始化一次，不需要在每次调用时都进行初始化。也就是说，它的值在两次调用之间保持不变。

```c
#include <stdio.h>

void counter(void)
{
    static int count = 1;  // This is initialized one time

    printf("This has been called %d time(s)\n", count);

    count++;
}

int main(void)
{
    counter();  // "This has been called 1 time(s)"
    counter();  // "This has been called 2 time(s)"
    counter();  // "This has been called 3 time(s)"
    counter();  // "This has been called 4 time(s)"
}
```

`static`用在块作用域之外时，就属于文件作用域。它的含义有所变化，意味着该变量只在当前文件内可见，在其他文件都不可见。

### extern

`extern`说明该变量在其他文件里面定义。

```c
extern int a;
```

函数默认就是`extern`，如果只希望函数在当前文件可用，那就需要在函数前面加上`static`。

### register

`register`向编译器表示该变量是经常使用的，应尽可能快地访问。但是，编译器可以忽略它。

```c
#include <stdio.h>

int main(void)
{
    register int a;   // Make "a" as fast to use as possible.

    for (a = 0; a < 10; a++)
        printf("%d\n", a);
}
```

设为`register`的变量，不能获取它的地址。

```c
register int a;
int *p = &a; // 编译器报错
```

如果数组设为`register`，也不能获取整个数组或任一个数组成员的地址。

```c
register int a[] = {11, 22, 33, 44, 55};

int p = a;  // 编译器报错

int a = *(a + 2); // 编译器报错
```

历史上，CPU 内部的缓存，称为寄存器（register）。与内存相比，寄存器的访问速度快得多，所以使用它们可以提高速度。但是它们不在内存之中，所以没有内存地址，这就是为什么不能获取指向它们的指针地址。但是，现代编译器已经有巨大的进步，不管是否使用`register`关键字，都会尽可能使用寄存器，所以不保证一定会把这些变量放到寄存器。

