# 指针

指针是 C 语言最重要的概念之一，也是最难理解的概念之一。

## 简介

指针是什么？首先，它是一个值，这个值代表一个内存地址，因此指针相当于指向某个内存地址的路标。

字符`*`表示指针，通常跟在类型关键字的后面，表示指针指向的是什么类型的值。比如，`Char*`表示一个指向字符的指针，`float*`表示一个指向`float`类型的值的指针。

```c
int* intPtr;
```

上面示例声明了一个变量`intPtr`，它是一个指针，指向的内存地址存放的是一个整数。

星号`*`可以放在变量名与类型关键字之间的任何地方，下面的写法都是等价的。

```c
int   *intPtr;
int * intPtr;
int*  intPtr;
```

本教程使用星号紧跟在类型关键字后面的写法（即`int* intPtr;`），因为这样可以体现，指针变量本质上与其他变量并无区别，就是一个普通变量，只不过它的值是内存地址而已。

如果同一个指令声明两个指针变量，那么需要写成下面这样。

```c
int * foo, * bar;
```

上面示例中，`foo`和`bar`都是整数指针，原因是 C 语言只允许类型关键字同时声明多个变量，其他写法都没有这个效果。

```c
int* foo, bar;
```

上面示例中，`foo`是整数指针变量，而`bar`是整数变量，即`*`只对第一个变量生效。

如果指向自定义的数据结构（`struct`命令），那么指针写法如下。

```c
struct fraction* intFraction;
```

一个指针指向的可能还是指针，这时就要用两个星号`**`表示。

```c
int** foo;
```

上面示例表示变量`foo`是一个指针，指向的还是一个指针，第二个指针指向的则是一个整数。

## * 运算符

`*`这个符号除了表示指针以外，还可以作为运算符，用来取出指针变量所指向的内存地址里面的值。

```c
void increment(int* p) {
  *p = *p + 1;
}
```

上面示例声明了函数`increment()`，它的参数是一个整数指针`p`。函数体里面，`*p`就表示指针`p`所指向的那个值。对`*p`赋值，就表示改变指针所指向的值。

上面函数的作用是将参数值加`1`。该函数没有返回值，因为传入的是地址，函数体内部对该地址包含的值的操作，会影响到函数外部，所以不需要返回值。事实上，函数内部通过指针，将值传到外部，是 C 语言的常用方法。

```c
int x = 1;
increment(&x);
printf("%d\n", x); // 2
```

上面示例中，调用`increment()`函数以后，变量`x`的值就增加了1，因为就在于传入函数的是`x`的指针`&x`。

另外，对于需要大量存储空间的大型变量，复制变量值传入函数，非常浪费时间和时间，不如传入指针来得高效。

## & 运算符

`&`运算符用来取出一个变量所在的内存地址。

```c
int x = 1;
printf("x's address is %p\n", &x);
```

上面示例中，`x`是一个整数变量，`&x`就是`x`的值所在的内存地址。`printf()`的`%p`是内存地址的占位符。

## 指针变量的初始化

`&`运算符常用来为指针变量赋值，其中一个重要用途，就是指针变量的初始化。

```c
int* p;
int i;

p = &i;
*p = 13;
```

上面示例中，`p`是指针变量，声明这个变量的时候，C 语言不会对该变量进行初始化，即不会为它分配内存地址，`p`会指向一个随机的内存地址。所以，这时不能直接对`*p`赋值，如果直接执行`*p = 13;`，就相当于对那个随机的内存地址进行赋值，可能产生意想不到的结果。

这意味着，声明指针变量以后，必须有初始化的步骤，即必须将它指向一个已经分配好的内存地址。上例中，就是再声明一个整数变量`i`，编译器会为`i`分配内存地址，然后让`p`指向`i`的内存地址（`p = &i;`），再对`p`指向的内存地址进行赋值。

进一步说，任何未初始化的指针变量，都不应该使用`*`运算符，去取值或赋值，因为那是毫无意义的。

```c
// 错误
int *p;
*p = 1;
```

上面示例中，指针变量`p`未进行初始化，就对`*p`赋值，是错误的写法。

为了防止这种错误，可以养成习惯，将未初始化的指针变量设为 NULL，表示指针尚未初始化，目前不指向任何地址。

```c
int* p;
p = NULL;
```

## void 指针

void 指针指的是不限定指针指向什么类型的数据。某些函数的返回值就是 void 指针，比如`memcpy()`函数。

```c
void* memcpy(void* s1, void* s2, size_t n);
void* memmove(void* s1, void* s2, size_t n);
```

上面代码中，`s1`和`s2`是内存地址的指针，之所以是`void*`，指的是各种类型的指针都可以。第三个参数`n`是要拷贝的字节数，注意不是数组的成员个数。比如，如果要拷贝数组里面10个 double 类型的元素，`n`就等于`10*sizeof(double)`，而不是`10`。

因为`memcpy()`只是将一段内存的值，复制到另一段内存，所以不需要知道内存里面的数据是什么类型。下面是复制字符串的例子。

```c
#include <stdio.h>
#include <string.h>

int main(void)
{
    char s[] = "Goats!";
    char t[100];

    memcpy(t, s, 7);  // Copy 7 bytes--including the NUL terminator!

    printf("%s\n", t);  // "Goats!"
}
```

下面是复制数值的例子。

```c
#include <stdio.h>
#include <string.h>

int main(void)
{
    int a[] = {11, 22, 33};
    int b[3];

    memcpy(b, a, 3 * sizeof(int));  // Copy 3 ints of data

    printf("%d\n", b[1]);  // 22
}
```

复制自定义 Struct 数据结构的例子。

```c
struct antelope my_antelope;
struct antelopy my_clone_antelope;

// ...

memcpy(&my_clone, &my_antelope, sizeof my_antelope);
```

注意，由于不知道 void 指针指向什么类型的值，所以不能用`*`运算符取出它指向的值。

```c
char a = 'X';
void* p = &a;

printf("%c\n", *p); // 报错
```

上面示例中，`p`是一个 void 指针，所以这时无法用`*p`取出指针指向的值。

使用 void 指针，我们也可以自己定义一个复制内存的函数。

```c
void* my_memcpy(void* dest, void* src, int byte_count) {
  char* s = src;
  char* d = dest;

  while (byte_count--) {
    *d++ = *s++;
  }

  return dest;

}
```

上面示例中，不管传入的`dest`和`src`是什么类型的指针，将它们重新定义成一字节的 Char 指针，这样就可以逐字节进行复制。最后，返回复制后的`dest`指针，便于后续使用。

### void* 指针

其他所有类型指针都可以转为`void*`指针，而`void*`指针也可以转为其他类型的指针。

```c
int x = 10;

void* p = &x; // &x 是 int 指针，转为 void* 指针

int *q = p; // p 是 void* 指针，转为 int 指针
```

## 指针的运算

指针本质上就是一个无符号整数，代表了内存地址。它可以进行运算，但是规则并不是整数运算的运算。

（1）指针与整数值的加减运算

指针与整数值的运算，表示指针的移动。

```c
short* j;
j = (short*)0x1234;
j = j + 1; // 0x1236
```

上面示例中，`j`是一个指针，指向内存地址`0x1234`。你可能以为`j + 1`等于`0x1235`，但正确答案是`0x1236`。原因是`j + 1`表示指针向高位移动一个单位，而一个单位的`short`类型占据两个字节的宽度，所以相当于向高位移动两个字节。同样的，`j - 1`得到的结果是`0x1232`。

指针移动的单位，与指针指向的数据类型有关。数据类型占据多少个字节，每单位就移动多少个字节。

（2）指针与指针的加法运算

指针只能与整数值进行加减运算，两个指针进行加法是非法的。

```c
unsigned short* j;
unsigned short* k;
x = j + k; // 非法
```

上面示例是两个指针相加，这是非法的。

（3）指针与指针的减法

相同类型的指针允许进行减法运算，返回它们之间的距离，即相隔多少个数据单位。

这时，减法返回的值不是指针类型，而是`ptrdiff_t`类型，表示带符号的整数，具体类型根据系统不同而不同。这个类型的原型定义在头文件`stddef.h`里面。

高位地址减去低位地址，返回的是正值；低位地址减去高位地址，返回的是负值。

（4）指针与指针的比较运算

指针之间的比较运算，比较的是各自的内存地址，返回整数`1`（true）或`0`（false）。

