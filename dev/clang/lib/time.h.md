# time.h

## clock()

`clock()`函数返回从程序开始执行到当前的 CPU 时钟周期。一个时钟周期等于 CPU 频率的倒数，比如 CPU 的频率如果是 1G Hz，表示1秒内时钟信号可以变化 10^9 次，那么每个时钟周期就是 10^-9 秒。

```c
clock_t　clock(void);
```

`clock()`函数返回一个数字，表示从程序开始到现在的 CPU 时钟周期的次数。为了把这个值转换为秒，应该把它除以常量`CLOCKS_PER_SEC`（每秒的时钟周期），这个常量也由`time.h`定义。

如果计算机无法提供 CPU 时间，或者返回值太大，无法用`clock_t`类型表示，`clock()`函数就返回`-1`。

为了知道某个操作所耗费的精确时间，需要调用两次`clock()`，然后将两次的返回值相减。

```c
clock_t start = clock();

// ... 执行某些操作

clock_t end = clock();

long double seconds = (float)(end - start) / CLOCKS_PER_SEC;
```

## time()

`time()`函数返回从纪元时间到现在经过的秒数。对于 Unix/Linux 系统，纪元时间一般为1970年1月1日00:00:00，这个时间又被称为”Unix 纪元“。这个纪元之前的时间，可以用负值表示。

```c
time_t time(time_t* returned_value);
```

`time()`接受一个指针变量作为参数，通过这个指针可以获取返回值的存储位置。如果参数是 NULL，表示不需要获取返回值指针。

`time()`的返回值类型是`time_t`，它是32位或64位整数类型的别名，取决于当前的计算机。如果是32位整数，可以表示的时间范围范围总共为136年；如果是64位整数，可以表示`-2930`亿年到`+2930`亿年的时间范围。

如果计算机无法提供当前的秒数，或者返回值太大，无法用`time_t`类型表示，`time()`函数就返回`-1`。

为了知道某个操作所耗费的精确时间，需要调用两次`time()`，然后将两次的返回值相减。

```c
time_t begin = time(NULL);

// ... 执行某些操作

time_t end = time(NULL);

printf("%d\n", end - begin);
```

注意，上面方法只能精确到秒。

## ctime()

```c
char *ctime( time_t const *time_value );
double difftime( time_t time1, time_t time2 );
```

`ctime()`函数的参数是一个指向time_t的指针，并返回一个指向字符串的指针，字符串的格式如下所示：

Sun Jul 4 04:02:48 1976\n\0

字符串内部的空格是固定的。一个月的每一天总是占据两个位置，即使第1个是空格。时间值的每部分都用两个数字表示。标准并未提及存储这个字符串的内存类型，许多编译器使用一个静态数组。因此，下一次调用ctime时，这个字符串将被覆盖。因此，如果你需要保存它的值，应该事先为其复制一份。注意ctime实际上可能以下面这种方式实现：

```c
asctime( localtime( time_value ) );
```

difftime函数计算time1-time2的差，并把结果值转换为秒。注意它返回的是一个double类型的值。

##

接下来的两个函数把一个time_t值转换为一个tm结构，后者允许我们很方便地访问日期和时间的各个组成部分。

struct　tm *gmtime( time_t　const *time_value );
struct　tm *localtime( time_t　const *time_value );
gmtime函数把时间值转换为世界协调时间(Coordinated Universal Time, UTC)。UTC以前被称为格林尼治标准时间(Greenwich Mean Time)，这也是gmtime这个名字的来历。正如其名字所提示的那样，localtime函数把一个时间值转换为当地时间。

标准包含了这两个函数，但它并没有描述UTC和当地时间的实现之间的关系。

tm结构包含了表16.2所列出的字段，不过这些字段在结构中出现的顺序并不一定如此。


类型 & 名称

范　　围

含　　义

int　tm_sec;

0-61（包含闰秒）

分之后的秒数*

int　tm_min;

0-59

小时之后的分数

int　tm_hour;

0-23

午夜之后的小时数

int　tm_mday;

1-31

当月的日期

int　tm_mon;

0-11

1月之后的月数

int　tm_year;

0-??

1900之后的年数

int　tm_wday;

0-6

星期天之后的天数

int　tm_yday;

0-365

1月1日之后的天数

int　tm_isdat;

夏令时标志

当你拥有了一个tm结构之后，你既可以直接使用它的值，也可以把它作为参数传递给下面的函数之一。

```c
char *asctime( struct tm const*tm_ptr );
size_t strftime( char *string, size_t maxsize, char const *format,
struct tm const *tm_ptr );
```

asctime函数把参数所表示的时间值转换为一个以下面的格式表示的字符串：

Sun Jul 4 04:02:48 1976\n\0

这个格式和ctime函数所使用的格式一样，后者在内部很可能调用了asctime来实现自己的功能。

## strftime()

`strftime()`函数把一个tm结构转换为一个根据某个格式字符串而定的字符串。这个函数在格式化日期方面提供了令人难以置信的灵活性。如果转换结果字符串的长度小于maxsize参数，那么该字符串就被复制到第1个参数所指向的数组中，strftime函数返回字符串的长度。否则，函数返回-1且数组的内容是未定义的。

格式字符串包含了普通字符和格式代码。普通字符被复制到它们原先在字符串中出现的位置。格式代码则被一个日期或时间值代替。格式代码包括一个%字符，后面跟一个表示所需值的字符。表16.3列出了已经实现的格式代码。如果%字符后面是一个其他任何字符，其结果是未定义的，这就允许各个编译器自由地定义额外的格式代码。你应该避免使用这种自定义的格式代码，除非你不怕牺牲代码的可移植性。特定于locale的值由当前的locale决定，它将在本章的后面讨论。%U和%W代码基本相同，区别在于前者把当年的第1个星期日作为第1个星期的开始而后者把当年的第1个星期一作为第1个星期的开始。如果无法判断时区，%Z代码就由一个空字符串代替。


%%

一个%字符

%a

一星期的某天，以当地的星期几的简写形式表示

%A

一星期的某天，以当地的星期几的全写形式表示

%b

月份，以当地月份名的简写形式表示

%B

月份，以当地月份名的全写形式表示

%c

日期和时间，使用%x %X

%d

一个月的第几天(01-31)

%H

小时，以24小时的格式(00-23)

%I

小时，以12小时的格式(00-12)

%J

一年的第几天(001-366)

%M

月数(01-12)

%M

分钟（00～59）

%P

AM或PM（不论哪个合适）的当地对等表示形式

%S

秒(00-61)

%U

一年的第几星期(00-53)，以星期日为第1天

%w

一星期的第几天，星期日为第0天

%W

一年的第几星期(00-53)，以星期一为第1天

%x 日期，使用本地的日期格式
%X 时间，使用本地的时间格式
%y 当前世纪的年份(00-99)
%Y 年份的全写形式(例如，1984)
%Z 时区的简写

## mktime()

最后，mktime函数用于把一个tm结构转换为一个time_t值。

time_t　mktime(struct tm* tm_ptr);

tm结构中tm_wday和tm_yday的值被忽略，其他字段的值也无需限制在它们的通常范围内。在转换之后，该tm结构会进行规格化，因此tm_wday和tm_yday的值将是正确的，其余字段的值也都位于它们通常的范围之内。这个技巧是一种简单的用于判断某个特定的日期属于星期几的方法。

## 参考链接

- [How to Measure Execution Time of a Program](https://serhack.me/articles/measure-execution-time-program/)

