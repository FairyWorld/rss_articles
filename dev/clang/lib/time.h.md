# time.h

## clock()

`clock()`函数返回从程序开始执行起处理器所消耗的时间。

```c
clock_t　clock(void);
```

`clock()`函数返回一个数字，通常是处理器时钟周期的次数。为了把这个值转换为秒，你应该把它除以常量`CLOCKS_PER_SEC`。

如果机器无法提供处理器时间，或者如果时间值太大，无法用`clock_t`类型表示，函数就返回`-1`。

## time()

`time()`函数返回当前的日期和时间。

```c
time_t　time(time_t* returned_value);
```

这个函数通常返回从1970年1月1日00:00:00开始流逝的秒数。

如果参数是一个非 NULL 的指针，时间值也将通过这个指针进行存储。

如果机器无法提供当前的日期和时间，或者时间值太大，无法用`time_t`变量表示，函数就返回`-1`。

## ctime()

```c
char *ctime( time_t const *time_value );
double difftime( time_t time1, time_t time2 );
```

`ctime()`函数的参数是一个指向time_t的指针，并返回一个指向字符串的指针，字符串的格式如下所示：

Sun Jul 4 04:02:48 1976\n\0

字符串内部的空格是固定的。一个月的每一天总是占据两个位置，即使第1个是空格。时间值的每部分都用两个数字表示。标准并未提及存储这个字符串的内存类型，许多编译器使用一个静态数组。因此，下一次调用ctime时，这个字符串将被覆盖。因此，如果你需要保存它的值，应该事先为其复制一份。注意ctime实际上可能以下面这种方式实现：

```c
asctime( localtime( time_value ) );
```

difftime函数计算time1-time2的差，并把结果值转换为秒。注意它返回的是一个double类型的值。

##

接下来的两个函数把一个time_t值转换为一个tm结构，后者允许我们很方便地访问日期和时间的各个组成部分。

struct　tm *gmtime( time_t　const *time_value );
struct　tm *localtime( time_t　const *time_value );
gmtime函数把时间值转换为世界协调时间(Coordinated Universal Time, UTC)。UTC以前被称为格林尼治标准时间(Greenwich Mean Time)，这也是gmtime这个名字的来历。正如其名字所提示的那样，localtime函数把一个时间值转换为当地时间。

标准包含了这两个函数，但它并没有描述UTC和当地时间的实现之间的关系。

tm结构包含了表16.2所列出的字段，不过这些字段在结构中出现的顺序并不一定如此。


类型 & 名称

范　　围

含　　义

int　tm_sec;

0-61（包含闰秒）

分之后的秒数*

int　tm_min;

0-59

小时之后的分数

int　tm_hour;

0-23

午夜之后的小时数

int　tm_mday;

1-31

当月的日期

int　tm_mon;

0-11

1月之后的月数

int　tm_year;

0-??

1900之后的年数

int　tm_wday;

0-6

星期天之后的天数

int　tm_yday;

0-365

1月1日之后的天数

int　tm_isdat;

夏令时标志

当你拥有了一个tm结构之后，你既可以直接使用它的值，也可以把它作为参数传递给下面的函数之一。

```c
char *asctime( struct tm const*tm_ptr );
size_t strftime( char *string, size_t maxsize, char const *format,
struct tm const *tm_ptr );
```

asctime函数把参数所表示的时间值转换为一个以下面的格式表示的字符串：

Sun Jul 4 04:02:48 1976\n\0

这个格式和ctime函数所使用的格式一样，后者在内部很可能调用了asctime来实现自己的功能。

## strftime()

`strftime()`函数把一个tm结构转换为一个根据某个格式字符串而定的字符串。这个函数在格式化日期方面提供了令人难以置信的灵活性。如果转换结果字符串的长度小于maxsize参数，那么该字符串就被复制到第1个参数所指向的数组中，strftime函数返回字符串的长度。否则，函数返回-1且数组的内容是未定义的。

格式字符串包含了普通字符和格式代码。普通字符被复制到它们原先在字符串中出现的位置。格式代码则被一个日期或时间值代替。格式代码包括一个%字符，后面跟一个表示所需值的字符。表16.3列出了已经实现的格式代码。如果%字符后面是一个其他任何字符，其结果是未定义的，这就允许各个编译器自由地定义额外的格式代码。你应该避免使用这种自定义的格式代码，除非你不怕牺牲代码的可移植性。特定于locale的值由当前的locale决定，它将在本章的后面讨论。%U和%W代码基本相同，区别在于前者把当年的第1个星期日作为第1个星期的开始而后者把当年的第1个星期一作为第1个星期的开始。如果无法判断时区，%Z代码就由一个空字符串代替。


%%

一个%字符

%a

一星期的某天，以当地的星期几的简写形式表示

%A

一星期的某天，以当地的星期几的全写形式表示

%b

月份，以当地月份名的简写形式表示

%B

月份，以当地月份名的全写形式表示

%c

日期和时间，使用%x %X

%d

一个月的第几天(01-31)

%H

小时，以24小时的格式(00-23)

%I

小时，以12小时的格式(00-12)

%J

一年的第几天(001-366)

%M

月数(01-12)

%M

分钟（00～59）

%P

AM或PM（不论哪个合适）的当地对等表示形式

%S

秒(00-61)

%U

一年的第几星期(00-53)，以星期日为第1天

%w

一星期的第几天，星期日为第0天

%W

一年的第几星期(00-53)，以星期一为第1天

%x 日期，使用本地的日期格式
%X 时间，使用本地的时间格式
%y 当前世纪的年份(00-99)
%Y 年份的全写形式(例如，1984)
%Z 时区的简写

## mktime()

最后，mktime函数用于把一个tm结构转换为一个time_t值。

time_t　mktime(struct tm* tm_ptr);

tm结构中tm_wday和tm_yday的值被忽略，其他字段的值也无需限制在它们的通常范围内。在转换之后，该tm结构会进行规格化，因此tm_wday和tm_yday的值将是正确的，其余字段的值也都位于它们通常的范围之内。这个技巧是一种简单的用于判断某个特定的日期属于星期几的方法。
